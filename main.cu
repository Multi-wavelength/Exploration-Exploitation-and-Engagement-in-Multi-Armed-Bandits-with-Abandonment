#include "basic_functions.cuh"
#include <iostream>
#include <thrust/host_vector.h>
#include <thrust/device_vector.h>
#include "constants.cuh"
#include "basic_functions.cuh"
#include <thrust/copy.h>
#include <thrust/fill.h>
#include <thrust/transform.h>
#include <fstream>
#include <string>
#include "main_functions.cuh"
#include <ctime>
#include <cstdlib>
#include <thrust/reduce.h>
#include <thrust/transform_reduce.h>
#include <thrust/functional.h>
#include <thrust/sequence.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/for_each.h>
#include <thrust/zip_function.h>
#include <thrust/transform_reduce.h>
#include <thrust/device_vector.h>
#include <thrust/pair.h>
#include <thrust/random.h>
#include <thrust/extrema.h>
#include <cstdlib>
#include <random>
#include <curand_kernel.h>
#include <thrust/device_ptr.h>


int main_5(int mode, float UCB_COEFFICIENTS_0, float UCB_COEFFICIENTS_1)
{
    thrust::device_vector<float_K> regret_device(NUM_SIMS);
    thrust::device_vector<float> regret_cumsum_device(NUM_SIMS);
    thrust::device_vector<float_num_arms> estimate(NUM_SIMS);
    thrust::device_vector<int_num_arms> num_pulls(NUM_SIMS);
    thrust::device_vector<float_num_states_num_arms> q_table(NUM_SIMS);
    thrust::device_vector<int> time_step(NUM_SIMS);
    thrust::device_vector<int_num_states_num_states> num_state_reward_table(NUM_SIMS);
    thrust::device_vector<int_num_states_num_states> num_state_reward_terminal_table(NUM_SIMS);

    std::ofstream fout;
    thrust::counting_iterator<unsigned long long> index_sequence_begin(unsigned long long(1e10));
    thrust::host_vector<float_K> regret_host(NUM_SIMS);
    float_num_arms mu;
    float mean_regret[K * NUM_KS];
    float std_regret[K * NUM_KS];

    thrust::fill(regret_cumsum_device.begin(), regret_cumsum_device.end(), 0.0f);

    float gap[SIZE_OF_VALUE_FUNCTION] = { 0.0f };
    if (mode == 8)
    {
        std::ifstream fin;
        fin.open("gap.txt");
        for (int i = 0; i < SIZE_OF_VALUE_FUNCTION; i++)
        {
            fin >> gap[i];
        }
        fin.close();
    }

    for (int i = 0; i < NUM_ARMS; i++)
    {
        mu.x[i] = MU[i];
    }

    if (mode == 1 || mode == 2 || mode == 3)
    {
        UCB_regret ucb_op(UCB_COEFFICIENTS_0, UCB_COEFFICIENTS_1, mode, mu, time(NULL), true);
        for (unsigned long long i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, estimate.begin(), num_pulls.begin(), time_step.begin(), regret_device.begin(), regret_cumsum_device.begin())),
                thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), estimate.end(), num_pulls.end(), time_step.end(), regret_device.end(), regret_cumsum_device.end())),
                thrust::make_zip_function(ucb_op));
            ucb_op.flag_first = false;
            
            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }
            
            std::cout << float(i) / NUM_KS << " ";
        }
    }
    else if (mode == 4 || mode == 5 || mode == 6 || mode == 11)
    {
        KL_UCB_regret ucb_op(UCB_COEFFICIENTS_0, UCB_COEFFICIENTS_1, mode, mu, time(NULL), true);
        for (int i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, estimate.begin(), num_pulls.begin(), time_step.begin(), regret_device.begin(), regret_cumsum_device.begin())),
                thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), estimate.end(), num_pulls.end(), time_step.end(), regret_device.end(), regret_cumsum_device.end())),
                thrust::make_zip_function(ucb_op));
            ucb_op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }

            std::cout << float(i) / NUM_KS << " ";
        }
    }
    else if (mode == 7 || mode == 8 || mode == 9 || mode == 10 || mode == 12 || mode == 13 || mode == 14 || mode == 15)
    {
        UCB_cont_regret ucb_op(UCB_COEFFICIENTS_0, UCB_COEFFICIENTS_1, mode, mu, time(NULL), true, gap);
        for (int i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, estimate.begin(), num_pulls.begin(), time_step.begin(), regret_device.begin(), regret_cumsum_device.begin())),
                thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), estimate.end(), num_pulls.end(), time_step.end(), regret_device.end(), regret_cumsum_device.end())),
                thrust::make_zip_function(ucb_op));
            ucb_op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }
            
            std::cout << float(i) / NUM_KS << " ";
        }
    }
    else if (mode == 16)
    {
        thrust::device_vector<int_num_states_num_arms> num_pulls_table(NUM_SIMS);
        Q_learning op(mode, mu, time(NULL), true, UCB_COEFFICIENTS_0);
        for (unsigned long long i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, q_table.begin(), num_pulls_table.begin(), time_step.begin(), regret_device.begin(), regret_cumsum_device.begin())),
                             thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), q_table.end(), num_pulls_table.end(), time_step.end(), regret_device.end(), regret_cumsum_device.end())),
                             thrust::make_zip_function(op));
            op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }

            std::cout << float(i) / NUM_KS << " ";
        }
        thrust::host_vector<float_num_states_num_arms> q_table_host(NUM_SIMS);
        thrust::copy(q_table.begin(), q_table.end(), q_table_host.begin());
        thrust::host_vector<int> time_step_host(NUM_SIMS);
        thrust::copy(time_step.begin(), time_step.end(), time_step_host.begin());
        std::cout << q_table_host[0].x[1][0] << std::endl;
        std::cout << q_table_host[0].x[1][1] << std::endl;
        std::cout << time_step_host[0] << std::endl;
    }
    else if (mode == 17)
    {
        thrust::device_vector<int_num_states_num_arms> num_pulls_table(NUM_SIMS);
        float iota = std::logf(NUM_STATES * NUM_ARMS * Q_UCB_H * Q_UCB_H * 1000 * 1000);
        Q_learning_ucb ucb_op(mode, mu, time(NULL), true, UCB_COEFFICIENTS_0, Q_UCB_H, iota);
        for (unsigned long long i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, q_table.begin(), num_pulls_table.begin(), time_step.begin(), regret_device.begin(), regret_cumsum_device.begin())),
                thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), q_table.end(), num_pulls_table.end(), time_step.end(), regret_device.end(), regret_cumsum_device.end())),
                thrust::make_zip_function(ucb_op));
            ucb_op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }

            std::cout << float(i) / NUM_KS << " ";
        }
        thrust::host_vector<float_num_states_num_arms> q_table_host(NUM_SIMS);
        thrust::copy(q_table.begin(), q_table.end(), q_table_host.begin());
        thrust::host_vector<int> time_step_host(NUM_SIMS);
        thrust::copy(time_step.begin(), time_step.end(), time_step_host.begin());
        std::cout << q_table_host[0].x[1][0] << std::endl;
        std::cout << q_table_host[0].x[1][1] << std::endl;
        std::cout << time_step_host[0] << std::endl;
    }
    else if (mode == 18)
    {
        thrust::device_vector<float_num_states> value_table(NUM_SIMS);
        thrust::device_vector<float_num_states_num_arms> reward_table(NUM_SIMS);
        thrust::device_vector<int_num_states_num_arms> num_pulls_table(NUM_SIMS);
        thrust::device_vector<int_num_states_num_arms_num_states> num_pulls_sas_table(NUM_SIMS);
        thrust::device_vector<int_num_states_num_arms> next_update_num_pulls(NUM_SIMS);
        thrust::device_vector<float_num_states_num_arms> pre_e_tilde(NUM_SIMS);
        float h_temp = 4.0f * BASELINE / C_MIN * std::logf(2.0f / BETA) + 1.0f;
        int H_SSP = int(std::roundf(std::powf(2.0f, std::ceilf(std::log2f(h_temp)))));
        
        int threshold;
        if (UCB_COEFFICIENTS_0 <= 0.0001)
        {
            threshold = 21003;
        }
        else if (UCB_COEFFICIENTS_0 <= 0.001)
        {
            threshold = 18654;
        }
        else if (UCB_COEFFICIENTS_0 <= 0.01)
        {
            threshold = 16288;
        }
        else if (UCB_COEFFICIENTS_0 <= 0.1)
        {
            threshold = 13901;
        }
        else
        {
            threshold = 11481;
        }

        SVI_SSP op(mode, mu, true, H_SSP, UCB_COEFFICIENTS_0, threshold);

        for (unsigned long long i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, q_table.begin(), value_table.begin(),
                                                                          reward_table.begin(), num_pulls_table.begin(), num_pulls_sas_table.begin(),
                                                                          next_update_num_pulls.begin(), pre_e_tilde.begin(),
                                                                          regret_device.begin(), regret_cumsum_device.begin())),
                             thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), q_table.end(), value_table.end(),
                                                                          reward_table.end(), num_pulls_table.end(), num_pulls_sas_table.end(), 
                                                                          next_update_num_pulls.end(), pre_e_tilde.end(),
                                                                          regret_device.end(), regret_cumsum_device.end())), thrust::make_zip_function(op));
            op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }

            std::cout << float(i) / NUM_KS << " ";
        }
        thrust::host_vector<float_num_states_num_arms> q_table_host(NUM_SIMS);
        thrust::copy(q_table.begin(), q_table.end(), q_table_host.begin());
        std::cout << q_table_host[0].x[1][0] << std::endl;
        std::cout << q_table_host[0].x[1][1] << std::endl;

    }
    else if (mode == 19)
    {
        float delta = 1.0f / 1000.0f;
        float iota = std::logf(5 * NUM_STATES * NUM_ARMS * Q_UCB_H * 1000 / delta);
        UCB_VI ucb_op(mode, mu, time(NULL), true, UCB_COEFFICIENTS_0, Q_UCB_H, iota);
        for (unsigned long long i = 0; i < NUM_KS; i++)
        {
            thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * i, q_table.begin(), estimate.begin(), num_pulls.begin(),
                num_state_reward_table.begin(), num_state_reward_terminal_table.begin(),
                regret_device.begin(), regret_cumsum_device.begin())),
                thrust::make_zip_iterator(thrust::make_tuple(index_sequence_begin + unsigned long long(NUM_SIMS) * (i + 1), q_table.end(), estimate.end(), num_pulls.end(),
                    num_state_reward_table.end(), num_state_reward_terminal_table.end(),
                    regret_device.end(), regret_cumsum_device.end())), thrust::make_zip_function(ucb_op));

            ucb_op.flag_first = false;

            Regret_reduction binary_op;
            float_K init;
            for (int k = 0; k < K; k++)
            {
                init.x[k] = 0.0f;
            }
            float_K regret_sum = thrust::reduce(regret_device.begin(), regret_device.end(), init, binary_op);
            for (int k = 0; k < K; k++)
            {
                mean_regret[i * K + k] = regret_sum.x[k] / float(NUM_SIMS);
            }

            Regret_square unary_op(regret_sum);
            float_K regret_var = thrust::transform_reduce(regret_device.begin(), regret_device.end(), unary_op, init, binary_op);
            for (int k = 0; k < K; k++)
            {
                std_regret[i * K + k] = std::sqrtf(regret_var.x[k] / float(NUM_SIMS - 1));
            }

            std::cout << float(i) / NUM_KS << " ";
        }
        std::cout << std::endl;
        thrust::host_vector<float_num_states_num_arms> q_table_host(NUM_SIMS);
        thrust::copy(q_table.begin(), q_table.end(), q_table_host.begin());
        std::cout << "Q[1,0] = " << q_table_host[0].x[1][0] << std::endl;
        std::cout << "Q[1,1] = " << q_table_host[0].x[1][1] << std::endl;
    }
    else
    {
        std::cout << "Error about mode!" << std::endl;
        return 1;
    }

    // Create and open txt file
    std::string filename = "regret_data_temp/regret_data_";
    filename += std::to_string(mode);
    filename += '_';
    filename += std::to_string(UCB_COEFFICIENTS_0);
    filename += '_';
    filename += std::to_string(UCB_COEFFICIENTS_1);
    filename += ".txt";
    fout.open(filename);
    std::cout << "Finished! Writing Out..." << std::endl;
    for (int i = 0; i < K * NUM_KS; i++)
    {
        fout << mean_regret[i] << std::endl;
    }
    fout.close();

    // Create and open txt file
    std::string filename_2 = "regret_data_temp/regret_data_std_";
    filename_2 += std::to_string(mode);
    filename_2 += '_';
    filename_2 += std::to_string(UCB_COEFFICIENTS_0);
    filename_2 += '_';
    filename_2 += std::to_string(UCB_COEFFICIENTS_1);
    filename_2 += ".txt";
    fout.open(filename_2);

    for (int i = 0; i < K * NUM_KS; i++)
    {
        fout << std_regret[i] << std::endl;
    }
    fout.close();

    return 0;
}


int main()
{
    int mode;

    float UCB_COEFFICIENTS_0;
    float UCB_COEFFICIENTS_1;

    

    std::cout << "Please input mode" << std::endl;
    std::cout << "1 for state dependent UCB optimal parameters" << std::endl;
    std::cout << "2 for state dependent UCB optimal parameters with loglog term" << std::endl;
    std::cout << "3 for state dependent UCB and need to input parameters c0 and c1" << std::endl;

    std::cout << "4 for state dependent KL-UCB optimal parameters" << std::endl;
    std::cout << "5 for state dependent KL-UCB optimal parameters with loglog term" << std::endl;
    std::cout << "6 for state dependent KL-UCB and need to input parameters c0 and c1" << std::endl;
    std::cout << "11 for traditional KL-UCB and need to input parameters c0 and c1" << std::endl;

    std::cout << "7 for state dependent UCB for continuous state space: algorithm 1" << std::endl;
    // std::cout << "8 for state dependent UCB for continuous state space: algorithm 2" << std::endl;
    std::cout << "9 for traditional UCB for continuous state space" << std::endl;
    std::cout << "10 for state dependent UCB for continuous state space: algorithm 2, simple linear function" << std::endl;

    std::cout << "12 for state dependent KL-UCB for continuous state space: algorithm 1" << std::endl;
    // std::cout << "13 for state dependent KL-UCB for continuous state space: algorithm 2" << std::endl;
    std::cout << "14 for traditional KL-UCB for continuous state space" << std::endl;
    std::cout << "15 for state dependent KL-UCB for continuous state space: algorithm 2, simple linear function" << std::endl;

    std::cout << "16 for Q-learning, input epislon" << std::endl;
    std::cout << "17 for Q-learning with UCB" << std::endl;
    std::cout << "18 for SVI-SSP" << std::endl;
    std::cout << "19 for UCBVI" << std::endl;

    std::cin >> mode;
    
    switch (mode)
    {
    case 1:
    case 2:
    case 7:
    case 8:
    case 10:
        UCB_COEFFICIENTS_0 = -0.70710678f;
        UCB_COEFFICIENTS_1 = 0.70710678f;
        break;
    case 9:
        UCB_COEFFICIENTS_0 = 0.70710678f;
        UCB_COEFFICIENTS_1 = 0.70710678f;
        break;
    case 3:
        std::cin >> UCB_COEFFICIENTS_0 >> UCB_COEFFICIENTS_1;
        break;
    case 4:
    case 5:
    case 12:
    case 13:
    case 14:
    case 15:
        UCB_COEFFICIENTS_0 = 1.0f;
        UCB_COEFFICIENTS_1 = 1.0f;
        break;
    case 6:
        std::cin >> UCB_COEFFICIENTS_0 >> UCB_COEFFICIENTS_1;
        break;
    case 11:
        std::cin >> UCB_COEFFICIENTS_0 >> UCB_COEFFICIENTS_1;
        break;
    case 16:
        std::cin >> UCB_COEFFICIENTS_0;
        UCB_COEFFICIENTS_1 = UCB_COEFFICIENTS_0;
        break;
    case 17:
        UCB_COEFFICIENTS_0 = 4.0f;
        UCB_COEFFICIENTS_1 = 4.0f;
        break;
    case 18:
        std::cin >> UCB_COEFFICIENTS_0;  // failure probability
        UCB_COEFFICIENTS_1 = UCB_COEFFICIENTS_0;
        break;
    case 19:
        std::cin >> UCB_COEFFICIENTS_0;
        UCB_COEFFICIENTS_1 = UCB_COEFFICIENTS_0;
        break;
    }

    int exit_code = main_5(mode, UCB_COEFFICIENTS_0, UCB_COEFFICIENTS_1);

    return exit_code;
}