#ifndef BASIC_FUNCTIONS_CUH
#define BASIC_FUNCTIONS_CUH

#include <thrust/host_vector.h>
#include <thrust/device_vector.h>
#include "constants.cuh"
#include <thrust/reduce.h>
#include <thrust/transform.h>
#include <thrust/sequence.h>
#include <thrust/fill.h>
#include <thrust/functional.h>
#include <thrust/detail/config.h>
#include <thrust/detail/functional/placeholder.h>
#include <thrust/transform_reduce.h>
#include <thrust/device_vector.h>
#include <thrust/pair.h>
#include <thrust/random.h>
#include <thrust/extrema.h>


struct int_num_states_num_arms
{
    int x[NUM_STATES][NUM_ARMS];
};

struct int_num_states_num_states
{
    int x[NUM_STATES][NUM_STATES];
};


struct int_num_states_num_arms_num_states
{
    int x[NUM_STATES][NUM_ARMS][NUM_STATES + 1];
};

struct float_num_states_num_arms
{
    float x[NUM_STATES][NUM_ARMS];
};

struct float_num_states
{
    float x[NUM_STATES];
};

struct float_num_arms
{
    float x[NUM_ARMS];
};

struct int_num_arms
{
    int x[NUM_ARMS];
};

struct float_K
{
    float x[K];
};

struct Regret_reduction : public thrust::binary_function<float_K, float_K, float_K>
{
    __host__ __device__
        float_K operator()(const float_K& a, const float_K& b) const
    {
        float_K result;
        for (int i = 0; i < K; i++)
        {
            result.x[i] = a.x[i] + b.x[i];
        }

        return result;
    }
};

struct Regret_square : public thrust::unary_function<float_K, float_K>
{
    const float_K regret_sum;
    Regret_square(float_K _regret_sum) : regret_sum(_regret_sum) {}
    __host__ __device__
        float_K operator()(const float_K& a) const
    {
        float_K result;
        for (int i = 0; i < K; i++)
        {
            float temp = a.x[i] - regret_sum.x[i] / float(NUM_SIMS);
            result.x[i] = temp * temp;
        }
        return result;
    }
};


#endif // BASIC_FUNCTIONS_CUH



